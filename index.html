<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker News Live Cloud</title>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #00ff41; /* Cyberpunk Green */
            --highlight: #ccffcc;
            --dim-text: #003b00;
            --link-hover: #ffffff;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            background-color: var(--bg-color);
            font-family: 'Courier New', Courier, monospace;
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: var(--text-color);
            font-size: 12px;
            z-index: 1000;
            border-top: 1px solid var(--text-color);
            display: flex;
            justify-content: space-between;
            font-family: 'Courier New', Courier, monospace;
            text-transform: uppercase;
        }

        /* Matrix Background Canvas */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none; /* Let clicks pass through to the links */
        }

        /* Word Cloud Container */
        #canvas {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            z-index: 1; /* Sit above the matrix rain */
        }

        .cloud-item {
            position: absolute;
            text-decoration: none;
            color: var(--text-color);
            line-height: 1.1;
            white-space: nowrap;
            /* Smoothly animate movement when position changes */
            transition: left 0.8s ease-in-out, top 0.8s ease-in-out, opacity 0.5s ease;
            opacity: 0; 
            cursor: pointer;
            z-index: 10;
            padding: 2px 5px;
            border-radius: 2px;
            background: rgba(0,0,0,0.4); /* Slight backing to improve readability over rain */
            text-shadow: 0 0 4px rgba(0, 255, 65, 0.5);
        }

        .cloud-item:hover {
            color: #000;
            background: var(--text-color);
            z-index: 100;
            box-shadow: 0 0 15px var(--text-color);
            transition: none; /* Instant hover effect */
        }

        .cloud-item.hot {
            color: #ccffcc;
            font-weight: bold;
            text-shadow: 0 0 8px var(--text-color);
        }

        .loader {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 2px solid var(--text-color);
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <canvas id="matrix-bg"></canvas>
    <div id="canvas"></div>

    <div id="status-bar">
        <div style="display:flex; align-items:center;">
            <div id="spinner" class="loader"></div>
            <span id="status-text">Connecting to HN...</span>
        </div>
        <div id="count">Items: 0</div>
    </div>

    <script>
        // --- Configuration ---
        const HN_API_BASE = 'https://hacker-news.firebaseio.com/v0';
        const UPDATE_INTERVAL_MS = 10000; 
        const INITIAL_FETCH_COUNT = 60; // Fetch 60 initially
        const TOP_STORIES_LIMIT = 30;   // Then only monitor top 30
        const MAX_ITEMS = 150; 
        const GLITCH_CHARS = '!<>-_\\/[]{}—=+*^?#01';

        // --- State ---
        const state = {
            seenIds: new Set(),
            stories: [], // Ordered list: Index 0 is newest/center
            isFetching: false
        };

        const canvas = document.getElementById('canvas');
        const statusText = document.getElementById('status-text');
        const countText = document.getElementById('count');
        const spinner = document.getElementById('spinner');

        // --- Matrix Background Logic ---
        function initMatrix() {
            const c = document.getElementById("matrix-bg");
            const ctx = c.getContext("2d");

            // Making the canvas full screen
            c.width = window.innerWidth;
            c.height = window.innerHeight;

            // Matrix characters - mix of Katakana and Latin
            const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
            const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const chars = (katakana + latin).split("");

            const fontSize = 14;
            const columns = c.width / fontSize; // number of columns for the rain
            
            // an array of drops - one per column
            const drops = [];
            // x below is the x coordinate
            // 1 = y co-ordinate of the drop(same for every drop initially)
            for (let x = 0; x < columns; x++)
                drops[x] = 1; 

            // drawing the characters
            function drawMatrix() {
                // Black BG for the canvas
                // translucent BG to show trail
                ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                ctx.fillRect(0, 0, c.width, c.height);

                ctx.fillStyle = "#004400"; // Subtle dark green text
                ctx.font = fontSize + "px monospace";

                // looping over drops
                for (let i = 0; i < drops.length; i++) {
                    // a random chinese character to print
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    // x = i*fontSize, y = value of drops[i]*fontSize
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                    // sending the drop back to the top randomly after it has crossed the screen
                    // adding a randomness to the reset to make the drops scattered on the Y axis
                    if (drops[i] * fontSize > c.height && Math.random() > 0.975)
                        drops[i] = 0;

                    // incrementing Y coordinate
                    drops[i]++;
                }
            }

            // Update every 120ms instead of 50ms for a slower, more ambient effect
            setInterval(drawMatrix, 120);

            // Handle resize for matrix
            window.addEventListener('resize', () => {
                c.width = window.innerWidth;
                c.height = window.innerHeight;
                // re-init drops roughly
                const newCols = c.width / fontSize;
                for (let x = 0; x < newCols; x++) {
                    if (!drops[x]) drops[x] = Math.floor(Math.random() * c.height/fontSize); 
                }
            });
        }


        // --- Geometry & Layout Engine ---

        function isIntersecting(r1, r2) {
            return !(r2.left > r1.right || 
                     r2.right < r1.left || 
                     r2.top > r1.bottom || 
                     r2.bottom < r1.top);
        }

        function checkCollision(rect, existingRects) {
            for (let other of existingRects) {
                const padding = 1; // Smaller padding for tighter fit
                const paddedOther = {
                    left: other.left - padding,
                    right: other.right + padding,
                    top: other.top - padding,
                    bottom: other.bottom + padding
                };
                if (isIntersecting(rect, paddedOther)) return true;
            }
            return false;
        }

        // --- Layout Calculation: Tetris / Gravity Packing ---
        // This replaces the spiral logic. 
        // Strategy: New items get first dibs on the top. 
        // We iterate Y from top to bottom trying to place the item.

        function getGravityPosition(width, height, existingRects) {
            const startY = 40; // Start below the "ceiling" (avoid overlapping header if we had one at top)
            const stepY = 10;
            const xTrials = 15; // Number of horizontal positions to attempt dropping into
            
            let bestPos = null;

            // Try several random X columns to find the one that lets the item float highest
            for (let i = 0; i < xTrials; i++) {
                // Try random X positions (keep inside screen width)
                const x = Math.floor(Math.random() * (window.innerWidth - width));
                
                let y = startY;
                let foundY = null;
                
                // Drop down until we fit or hit bottom
                // We check collision at steps. 
                while (y < window.innerHeight) {
                    const rect = {
                        left: x,
                        top: y,
                        right: x + width,
                        bottom: y + height
                    };
                    
                    if (!checkCollision(rect, existingRects)) {
                        foundY = y;
                        break; // Found the highest spot for this X
                    }
                    y += stepY;
                }
                
                if (foundY !== null) {
                    // We want the spot with the MINIMUM Y (highest up)
                    if (!bestPos || foundY < bestPos.y) {
                        bestPos = { x, y: foundY, rect: {
                            left: x,
                            top: foundY,
                            right: x + width,
                            bottom: foundY + height
                        }};
                    }
                }
            }
            
            return bestPos;
        }

        // --- DOM & Visuals ---

        function calculateFontSize(score) {
            // Updated for smaller text: Range 9px to 24px
            const base = 9;
            const maxAdd = 15;
            const cappedScore = Math.min(score, 600);
            const size = base + (Math.log(cappedScore + 1) / Math.log(601) * maxAdd);
            return Math.floor(size);
        }

        function createWordElement(story) {
            const el = document.createElement('a');
            // Always link to the Hacker News discussion page
            el.href = `https://news.ycombinator.com/item?id=${story.id}`;
            el.target = "_blank";
            el.className = 'cloud-item';
            el.textContent = story.title;
            el.dataset.original = story.title;
            el.dataset.id = story.id;
            el.id = `story-${story.id}`;

            const fontSize = calculateFontSize(story.score);
            el.style.fontSize = `${fontSize}px`;
            
            if (story.score > 100) el.classList.add('hot');

            // Add to DOM invisibly first
            el.style.visibility = 'hidden';
            canvas.appendChild(el);
            return el;
        }

        // --- Glitch Effect ---
        function runGlitch() {
            // Pick a few random visible elements
            const visibleItems = state.stories
                .map(s => document.getElementById(`story-${s.id}`))
                .filter(el => el && el.style.opacity === '1');

            if (visibleItems.length === 0) return;

            // Glitch 2 to 5 items per cycle (increased frequency)
            const glitchCount = Math.floor(Math.random() * 4) + 2;
            
            for (let i = 0; i < glitchCount; i++) {
                const el = visibleItems[Math.floor(Math.random() * visibleItems.length)];
                if (!el || el.dataset.glitching) continue;

                // Mark as glitching
                el.dataset.glitching = "true";
                const originalText = el.dataset.original;
                const len = originalText.length;
                
                // Decide how many chars to flip (Targeting ~50%)
                const flips = Math.max(1, Math.floor(len * 0.5));
                
                let newText = originalText.split('');
                
                // Pick random indices to flip
                const indicesToFlip = new Set();
                while (indicesToFlip.size < flips) {
                    indicesToFlip.add(Math.floor(Math.random() * len));
                }

                indicesToFlip.forEach(idx => {
                    if (newText[idx] !== ' ') { // Don't flip spaces
                        newText[idx] = GLITCH_CHARS[Math.floor(Math.random() * GLITCH_CHARS.length)];
                    }
                });
                
                el.textContent = newText.join('');
                
                // Restore
                setTimeout(() => {
                    if (el) {
                        el.textContent = originalText;
                        delete el.dataset.glitching;
                    }
                }, 100 + Math.random() * 150);
            }
        }

        // --- Core Logic: Relayout ---

        function relayout() {
            const occupiedRects = [];
            
            // Iterate through stories Newest -> Oldest.
            // Newest gets processed first, so it claims the top spots (Gravity Logic).
            
            state.stories.forEach((story, index) => {
                let el = document.getElementById(`story-${story.id}`);
                
                // If element doesn't exist (shouldn't happen often), create it
                if (!el) {
                    el = createWordElement(story);
                }

                const width = el.offsetWidth;
                const height = el.offsetHeight;

                // Find spot from top down
                const pos = getGravityPosition(width, height, occupiedRects);

                if (pos) {
                    el.style.left = `${pos.x}px`;
                    el.style.top = `${pos.y}px`;
                    el.style.visibility = 'visible';
                    el.style.opacity = 1;
                    
                    occupiedRects.push(pos.rect);
                } else {
                    // If we can't fit it (screen full or pushed off bottom)
                    // Set opacity 0 so it fades out
                    el.style.opacity = 0; 
                }
            });
        }

        // --- API & Data Management ---

        async function fetchItem(id) {
            try {
                const resp = await fetch(`${HN_API_BASE}/item/${id}.json`);
                return await resp.json();
            } catch (e) {
                return null;
            }
        }

        async function fetchTopStories() {
            if (state.isFetching) return;
            state.isFetching = true;
            spinner.style.display = 'inline-block';
            
            // Determine fetch limit: 60 on first run, 30 for updates
            const isFirstRun = state.stories.length === 0;
            const limit = isFirstRun ? INITIAL_FETCH_COUNT : TOP_STORIES_LIMIT;

            statusText.innerText = `Scanning Top ${limit}...`;
            
            try {
                const resp = await fetch(`${HN_API_BASE}/topstories.json`);
                const allIds = await resp.json();
                
                // Slice based on current mode
                const targetIds = allIds.slice(0, limit);
                
                // Check if any of these are new to us
                const newIds = targetIds.filter(id => !state.seenIds.has(id));
                
                if (newIds.length > 0) {
                    statusText.innerText = `Found ${newIds.length} new items...`;
                    
                    const newStories = [];
                    for (const id of newIds) {
                        const story = await fetchItem(id);
                        if (story && !story.deleted && !story.dead) {
                            state.seenIds.add(id);
                            newStories.push(story);
                        }
                    }

                    // Sort the NEW batch by time (newest first).
                    // On initial load, this ensures the screen is ordered by date.
                    // On updates, it ensures the newest of the new sits on top.
                    newStories.sort((a, b) => b.time - a.time);

                    // Add new stories to the BEGINNING of the array
                    if (newStories.length > 0) {
                        state.stories = [...newStories, ...state.stories];
                        
                        // Prune if too many total accumulated items
                        if (state.stories.length > MAX_ITEMS) {
                            const removed = state.stories.splice(MAX_ITEMS);
                            removed.forEach(s => {
                                const el = document.getElementById(`story-${s.id}`);
                                if (el) el.remove();
                                state.seenIds.delete(s.id);
                            });
                        }

                        relayout();
                        countText.innerText = `Items: ${state.stories.length}`;
                    }
                } else {
                    statusText.innerText = `Monitoring Top ${limit}...`;
                }
                
            } catch (e) {
                console.error(e);
                statusText.innerText = "Connection error.";
            } finally {
                state.isFetching = false;
                spinner.style.display = 'none';
                setTimeout(() => {
                    if (!state.isFetching) statusText.innerText = "Live / Waiting...";
                }, 2000);
            }
        }

        // --- Init ---
        function init() {
            initMatrix(); // Start the background
            fetchTopStories();
            setInterval(fetchTopStories, UPDATE_INTERVAL_MS);
            setInterval(runGlitch, 3000); 
            
            // Handle resize
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(relayout, 500);
            });
        }

        init();

    </script>
</body>
</html>
